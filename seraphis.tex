\documentclass{article}
\usepackage[top=1.0in,bottom=1.0in,left=1.0in,right=1.0in]{geometry}
\usepackage{amsmath,amssymb,amsthm,amsfonts}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{remark}{Remark}

\title{A Report on Seraphis}
\author{coinstudent2048}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document contains a concise description of Seraphis \cite{seraphis}, a novel privacy-preserving transaction protocol abstraction, and its security model. This document will also serve as a suggestion to the organization of the contents of the final Seraphis paper.
\end{abstract}

\section{Introduction}
In a p2p (peer-to-peer) electronic cash system, the entire supply of currency exists as a digital record that can be stored by any person, and transactions (attempts to transfer money to new owners) are mediated by a network of \textit{peers} (usually called \textit{nodes})... ...An unfortunate consequence of cryptocurrencies being decentralized is that the ledger is \textit{public}, implying that all e-notes and transaction events are public knowledge. If amounts are in cleartext, addresses are trivially traceable, and e-notes to be spent are referenced directly, then observers can discern many details about usersâ€™ finances.

Hence, several confidential transaction protocols have been proposed to ensure financial privacy and currency fungibility. [List privacy technologies and limitations]

We introduce Seraphis, privacy-preserving transaction protocol abstraction, which means the unlike previous...
\subsection{Concurrent Works}
Lelantus Spark

\section{Preliminaries}
\subsection{Public parameters}
Let $\lambda$ be the security parameter. Let $\mathbb{G}$ be a prime order group based on $\lambda$ where the Discrete Logarithm (DL), Computational Diffie-Hellman (CDH), and Decisional Diffie-Hellman (DDH) problems are hard, and let $\mathbb{F}$ be its scalar field. Let $G, H, U$ be generators of $\mathbb{G}$ with unknown DL relationship to each other. Note that these generators may be produced using public randomness. Let $a_{max}\in\mathbb{F}$ be the maximum amount value. Let $\mathcal{H}:\{0,1\}^*\rightarrow\mathbb{F}$ be a cryptographic hash function. We add a subscript to $\mathcal{H}$, such as $\mathcal{H}_1$, in lieu of domain-separating the hash function explicitly; any domain-separation method may be used in practice. All these public parameters are collected as $pp$, and we now define the setup algorithm: $pp\leftarrow\textsf{Setup}(1^{\lambda})$. $\textsf{Setup}$ is implicitly executed by all players involved in the beginning, hence it can be omitted in protocol descriptions.

The notation $\xleftarrow{\$}$ will be used to denote for a uniformly randomly chosen element, and $(1/x)$ for the modular inverse of $x\in\mathbb{F}$. Lastly, we use additive notation for group operations.

\subsection{E-notes and e-note images}
\begin{definition}\label{e-note}
An \textbf{\em e-note} for scalars $k_a^o, k_b^o, a \in\mathbb{F}$ is a tuple $(C, K^o, m)$ such that $C = x G + a H$ for $x\xleftarrow{\$}\mathbb{F}$, $K^o=k_b^o G + k_a^o U$, and $m$ is an arbitrary data.
\end{definition}
$C$ is called the \textbf{amount commitment} for the amount $a$ with blinding factor $x$, $K^o$ is called the \textbf{one-time address} for (one-time) private keys $k_a^o$ and $k_b^o$ (the $o$ superscript indicates ``one-time''), and $m$ is the \textbf{memo field}. We say that someone \textit{owns} an e-note if they know the corresponding scalars $k_a^o, k_b^o, a, x \in\mathbb{F}$.

\begin{definition}\label{e-note-img}
An \textbf{\em e-note image} for an e-note $(C, K^o, m)$ is a tuple $(C', K'^o, \tilde{K})$ such that
\begin{align*}
C' &= t_c G + C \\ &= (t_c+x)G + aH \\ &= v_c G + aH \ , \\
K'^o &= t_k G + K^o \\ &= (t_k + k_b^o) G + k_a^o U \\ &= v_k G + k_a^o U \ ,\ \text{and} \\
\tilde{K} &= (1/k_a^o)G
\end{align*}
for $t_c, t_k \xleftarrow{\$}\mathbb{F}$ and independent to each other.
\end{definition}
$C'$ is called the \textbf{masked amount commitment}, $K'^o$ is called the \textbf{masked address}, and $\tilde{K}$ is called the \textbf{linking tag}.

\begin{definition}\label{recv-addr}
A \textbf{\em receiver address} is a tuple $(K^{dh}, K^v, K^s)$  such that $K^{dh}\in\mathbb{G}$, $K^v = k^v K^{dh}$, and $K^s = k_b^s G + k_a^s U$.
\end{definition}
$K^{dh}$ is called the \textbf{Diffie-Hellman base public key}, the $v$ superscript indicates ``view'', and the $s$ superscript indicates ``spend''. The reason for the name of $K^{dh}$ will be clear in the next subsection, while the reason for the names of superscripts will be discussed in the addressing schemes (Subsection \ref{addr-scheme}). We say that someone \textit{owns} a receiver address if they know the corresponding scalars $k^v, k_a^s, k_b^s \in\mathbb{F}$.

\subsection{Symmetric encryption scheme}
We require the use of a symmetric encryption scheme. The Diffie-Hellman base public key enables shared secrets between the sender and the receiver, which can be used to produce the key for encryption. We denote the encryption and decryption of data $x$ with key $k$ as ${\tt enc}[k](x)$ and ${\tt dec}[k](x)$, respectively. We put overlines (e.g. $\overline{x}$) to indicate encrypted data.

\section{A Seraphis transaction}\label{ser-tx}
We now describe a simple Seraphis transaction. This will be used as the basis for further instantiations and modifications (Section \ref{inst}) and for the security model (Section \ref{sec}).

Suppose that Alice would send $a_t\in\mathbb{F}$ amount of funds to Bob. Alice owns a set of e-notes $\{(C_i,K_i^o,m_i)\}_{i=1}^n$ with a total amount of $\big(\sum_{i=1}^{n}{a_i}\big)\ge a_t$, all \textit{connected} to a receiver address $(K_{ali}^{dh}, K_{ali}^v, K_{ali}^s)$. This ``connection'' will be elaborated later on. On the other hand, Bob owns a receiver address $(K_{bob}^{dh}, K_{bob}^v, K_{bob}^s)$. For Bob to receive the funds, he will now send his receiver address to Alice. Alice will actually send funds to two addresses: to Bob's and to herself (for the ``change'' $a_c = \sum_{i=1}^{n}{a_i} - a_t$ \textit{even if} $a_c=0$). Hence, Alice must create 2 new e-notes. She starts the transaction by doing the following:
\begin{enumerate}
    \item Generate $r_{ali}, r_{bob}\xleftarrow{\$}\mathbb{F}$ and independent to each other.
    \item Compute $R_{ali} = r_{ali}K_{ali}^{dh}$ and $R_{bob} = r_{bob}K_{bob}^{dh}$, then store $R_{ali}$ and $R_{bob}$ to new (empty) memos $m_{ali}$ and $m_{bob}$, respectively. The name for $K^{dh}$ should now be clear.
    \item Compute the sender-receiver shared secrets $q_{ali} = \mathcal{H}_1(r_{ali}K_{ali}^{v})$ and $q_{bob} = \mathcal{H}_1(r_{bob}K_{bob}^{v})$.
    \item Compute the one-time addresses $K_{ali}^{o} = \mathcal{H}_2(q_{ali})U + K_{ali}^s$ and $K_{bob}^{o} = \mathcal{H}_2(q_{bob})U + K_{bob}^s$. It is easy to see that $\mathcal{H}_2(q_{ali})$ and $\mathcal{H}_2(q_{ali})$ are uniformly random in the random oracle model.
    \item Compute the amount commitments $C_{ali} = \mathcal{H}_3(q_{ali})G + a_c H$ and $C_{bob} = \mathcal{H}_3(q_{bob})G + a_t H$. It is easy to see that the blinding factors $\mathcal{H}_3(q_{ali})$ and $\mathcal{H}_3(q_{bob})$ are uniformly random in the random oracle model.
    \item Encrypt the amounts: $\overline{a_c} = {\tt enc}[q_{ali}](a_c)$ and $\overline{a_t} = {\tt enc}[q_{ali}](a_t)$, and store $\overline{a_c}$ and $\overline{a_t}$ to memos $m_{ali}$ and $m_{bob}$, respectively.
\end{enumerate}
Alice now has two new e-notes: ${\tt enote}_{ali} = (C_{ali}, K_{ali}^o, m_{ali})$ and ${\tt enote}_{bob} = (C_{bob}, K_{bob}^o, m_{bob})$. These will then be stored to a new (empty) \textit{whole transaction} $T$. Other objects that will be stored to the whole transaction are from proving systems, which can be executed in \textit{any} order. Proving systems are discussed in the next subsections.

For specific instances of Seraphis, there might be changes in some parts of the above steps, and by reflection, in some parts of the Receipt. Here are some notable changes:
\begin{itemize}
\item For some addressing schemes, the input to $\mathcal{H}_2$, the input to $\mathcal{H}_3$, and the key for both ${\tt enc}$ and ${\tt dec}$ may be constructed differently and different to each other. Nevertheless, these inputs and key must still be sender-receiver shared secrets.
\item A Seraphis transaction can easily have multiple receivers aside from Bob, which implies that Alice will create more than 2 new e-notes. See Subsection \ref{sec-disc} for a discussion of how this affects the security model.
\item A Seraphis transaction can be collaboratively constructed by multiple players. This is the subject of the so-called ``proof dependency'' (Subsection \ref{proof-dep}). Also see Subsection \ref{sec-disc} for a discussion of how this affects the security model.
\end{itemize}

\subsection{Ownership and unspentness proofs}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked address $K_i'^o$ is already in the e-note image ${\tt enimg}_i$ in $T$, then go to next step. Else generate $K_i'^o$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item If the linking tag $\tilde{K}_i$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $\tilde{K}_i$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item Prepare the proof transcripts $\Pi_{\text{o\&u}, i}$ for a non-interactive proving system for the following relation:
$$\{(G, U, K_i'^o, \tilde{K}_i\in\mathbb{G}; v_k, k_a^o\in\mathbb{F}): k_a^o \ne 0 \wedge K_i'^o = v_k G + k_a^o U \wedge \tilde{K}_i = (1/k_a^o)G \}$$
    \item Append $\Pi_{\text{o\&u}, i}$ to $({\tt enimg}_i, \ldots)$ in $T$.
\end{enumerate}
Aside from verifying the proof transcripts, the Verifier must confirm that the linking tags do not yet appear in the ledger.

\subsection{Amount balance}\label{amt-bal}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked amount commitment $C_i'$ is already in ${\tt enimg}_i$ in $T$, then exit this subsection. Else generate $C_i'$ from $(C_i, K_i^o, m_i)$ as per definition, \textit{except} for $i=n$. For the case of $i=n$, set
    $$v_{c,n} = \mathcal{H}_3(q_{ali}) + \mathcal{H}_3(q_{bob}) - \sum_{i=1}^{n-1}{v_{c,i}}.$$
    Note that the value of $v_{c,n}$ is still uniformly random because the values of $t_{c,i}$ for $i\in\{1,\ldots,n-1\}$ are uniformly random.
    \item Insert $C_i'$ to ${\tt enimg}_i$ in $T$.
\end{enumerate}
The generation of $v_{c,n}$ is as such so that the Verifier can verify the amount balance $\sum_{i=1}^n{C_i'}=C_{ali}+C_{bob}$.

\subsection{Membership proofs}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked amount commitment $C_i'$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $C_i'$ from $(C_i, K_i^o, m_i)$ exactly like in Step 1 of Subsection \ref{amt-bal}, and insert it to ${\tt enimg}_i$ in $T$.
    \item If the masked address $K_i'^o$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $K_i'^o$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item Collect $s-1$ number of random e-notes from the ledger and add her owned $(C_i,K_i^o,m_i)$, for a total of $s$ e-notes. The number $s$ is called the \textbf{anonymity size}.
    \item For each e-note in the collection (of size $s$), extract only the amount commitment and one-time address like this: $(C_j, K_j^o)$. Then arrange the $s$ e-notes in random positions. Alice now has an array (of length $s$) of pairs: $\mathbb{S}_i = \{(C_j, K_j^o)\}_{j=1}^s$, which is called the \textbf{ring}. Its elements $(C_j, K_j^o)$ are called the \textbf{ring members}. 
    \item Prepare the proof transcripts $\Pi_{\text{mem}, i}$ for a non-interactive proving system for the following relation:
$$\{(G, C_i', K_i'^o \in\mathbb{G}, \mathbb{S}_i\subset\mathbb{G}^2; \pi\in\mathbb{N}, t_c, t_k\in\mathbb{F}): 1\le\pi\le s \wedge C_i' - C_\pi = t_c G \wedge K_i'^o - K_\pi^o = t_k G \}$$
    \item Append $(\mathbb{S}_i, \Pi_{\text{mem}, i})$ to $({\tt enimg}_i, \ldots)$ in $T$.
\end{enumerate}

\subsection{Range proofs}
For the new e-notes ${\tt enote}_{ali}$ and ${\tt enote}_{bob}$, Alice must do the following:
\begin{enumerate}
    \item Prepare the respective proof transcripts $\Pi_{\text{ran}, ali}$ and $\Pi_{\text{ran}, bob}$ for a non-interactive proving system for the following relation:
$$\{(G, H, C \in\mathbb{G}, a_{max}\in\mathbb{F}; x, a\in\mathbb{F}): C = x G + a H \wedge 0\le a \le a_{max}\}$$
    \item Store $\Pi_{\text{ran}, ali}$ and $\Pi_{\text{ran}, bob}$ to $T$.
\end{enumerate}

\subsection{Receipt}
Once the construction of $T$ is completed, Alice sends it to the network. Its contents must now be
$$T=({\tt enote}_{ali}, {\tt enote}_{bob}, \Pi_{\text{ran}, ali}, \Pi_{\text{ran}, bob}, \{({\tt enimg}_i, \Pi_{\text{o\&u}, i}, \mathbb{S}_i, \Pi_{\text{mem}, i})\}_{i=1}^n).$$
\noindent Suppose that the Verifier successfully verified $T$, hence $T$ is now stored in the ledger. When Bob scans the ledger for new transactions, he must do the following for every $T$ he encounters:
\begin{enumerate}
    \item Get a new e-note $(C, K^o, m)$ in $T$. Note that $m$ contains $(R, \overline{a})$ (see the beginning of this whole section).
    \item Compute the nominal sender-receiver shared secret: $q_{nom} = \mathcal{H}_1(k_{bob}^v R)$.
    \item Compute the nominal spend public key: $K_{nom}^s = K^o - \mathcal{H}_2(q_{nom})U$. If $K_{nom}^s = K_{bob}^s$, then the e-note is \textit{connected} to Bob's receiver address, and proceed to the next step (this is the ``connection'' hinted at the beginning of this whole section).  Otherwise (if not equal), the e-note is not connected, and hence go to Step 1.
    \item Decrypt the amount: $a = {\tt dec}[q_{nom}](\overline a)$.
    \item Compute the nominal amount commitment: $C_{nom} = \mathcal{H}_3(q_{nom})G + a H$. If $C_{nom} \ne C$, then the e-note is malformed and cannot be spent.
    \item Compute the nominal linking tag: $\tilde{K}_{nom} = (1/(k_{a, bob}^s + \mathcal{H}_2(q_{nom})))G$. If he finds a copy of $\tilde{K}_{nom}$ in the ledger, then the e-note has already been spent.
\end{enumerate}
If an e-note $(C, K^o, m)$ is connected to Bob's receiver address, then he knows the corresponding scalars of that e-note: $(k_a^o, k_b^o, a, x) = (k_{a, bob}^s + \mathcal{H}_2(q_{nom}), k_{b, bob}^s, a, \mathcal{H}_3(q_{nom}))$. Hence, ``connection'' implies e-note ownership. The transaction is complete for Bob.

For Alice to receive the ``change'' e-note, she must do the same above steps. After that, the transcation is complete for Alice. This finishes a Seraphis trancation.

\section{Instantiations and Modifications}\label{inst}
There are a number of details to consider when implementing Seraphis in a real cryptocurrency. Aside from instances of proving systems mentioned already in the previous section, this section is comprised of `recommendations' for instantiations and modifications of other parts of Seraphis, which are inspired by historical privacy-focused cryptocurrency implementations.

\subsection{Addressing schemes}\label{addr-scheme}
\subsection{Multisignature operations}
\subsection{Proof dependency}\label{proof-dep}
\subsubsection*{Transaction Chaining}
\subsection{Transaction fees}
\subsection{Coinbase transactions}
\subsection{Squashed e-note model}
\subsection{?????}

\section{Security model}\label{sec}
For a start, we assume that the distributed ledger is immutable. Therefore, the adversary in our analysis will never be able to modify transactions already stored in the ledger. This ledger immutability can be actualized through, for instance, the Nakamoto consensus protocol \cite{bitcoin}.

Subsections \ref{ZKP} to \ref{Comm} outline the required security properties of the cryptographic components for Seraphis, then Subsection \ref{sec-thm} is the main security analysis of Seraphis, and Subsection \ref{sec-disc} discusses how some instantiations and modifications described in Section \ref{inst} affect the security analysis.

\subsection{Zero-knowledge proofs}\label{ZKP}
\begin{itemize}
    \item \textit{Completeness}:
    \item \textit{Special Soundness}:
    \item \textit{Special Honest Verifier Zero-Knowledge}:
\end{itemize}
Fiat-Shamir heuristic \cite{fiat-shamir} transforms sigma protocols with the above properties into non-interactive zero-knowledge proofs (NIZKPs) in the random oracle model. We require that the proving systems for Ownership and Unspentness proofs, and Range proofs are NIZKPs constructed through Fiat-Shamir heuristic.

\subsection{Symmetric encryption scheme}
We require that the symmetric encryption scheme has the following properties: indistinguishable against chosen-plaintext attack (IND-CPA), indistinguishable against adaptive chosen-ciphertext attack (IND-CCA2), and key-private under chosen-ciphertext attacks (IK-CCA).

\subsection{Membership proof security properties}
\begin{itemize}
    \item \textit{Completeness}:
    \item \textit{Unforgeability}:
    \item \textit{Anonymity}:
\end{itemize}

\subsection{Commitment schemes}\label{Comm}

We define a commitment scheme as a tuple $(\textsf{Setup}, \textsf{Comm})$. $\textsf{Setup}$ is the setup algorithm: $pp\leftarrow\textsf{Setup}(1^{\lambda})$, and $\textsf{Comm}:\mathcal{M}\times{\chi}\rightarrow\mathcal{C}$ is the $\textit{commitment function}$, where $\mathcal{M}$ is the message space, $\chi$ is the randomness space, and $\mathcal{C}$ is the commitment space. Note that $\mathcal{M}, \chi$ and $\mathcal{C}$ are all constructed from $pp$.
To commit to a message $m \in M$, the sender selects $r\xleftarrow{\$}\chi$ and computes the commitment $C = \textsf{Comm}(m; r)$. We define the required security properties of commitment schemes.

\begin{definition}[Hiding Property]
A commitment scheme $(\emph{\textsf{Setup}}, \emph{\textsf{Comm}})$ is hiding if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\left| \frac{1}{2} - \emph{\textsf{Pr}}\left[
\begin{array}{c|c}
    \begin{gathered}
        b' = b
    \end{gathered}
    &
    \begin{gathered}
        pp\leftarrow\textsf{Setup}(1^{\lambda}); (m_0, m_1)\leftarrow\mathcal{A}(pp); \\
        b\xleftarrow{\$}\{0,1\}; r \xleftarrow{\$}\chi; \\
        C = \emph{\textsf{Comm}}(m_b; r); b'\leftarrow\mathcal{A}(C)
    \end{gathered}
\end{array}
\right]\right|
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
\end{definition}

\begin{definition}[Binding Property]
A commitment scheme $(\emph{\textsf{Setup}}, \emph{\textsf{Comm}})$ is binding if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}
\left[
\begin{array}{c|c}
    \begin{gathered}
         \emph{\textsf{Comm}}(m_0;r_0) \\
        = \emph{\textsf{Comm}}(m_1;r_1) \\
        \wedge\ m_0 \ne m_1
    \end{gathered}
    &
    \begin{gathered}
        pp\leftarrow\textsf{Setup}(1^{\lambda}); \\
        (m_0,m_1,r_0,r_1)\leftarrow\mathcal{A}(pp)
    \end{gathered}
\end{array}
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
\end{definition}
\subsection{Seraphis security properties}\label{sec-thm}
The required security properties are those in Omniring's security model \cite{omniring}, with modifications to fit Seraphis. The Omniring paper presents a rigorous formalization of RingCT constructions, providing precision for security analysis against several realistic attacks. Proofs for the theorems are found in Section \ref{proofs}.

We first define commitment functions $\textsf{CommAmount}:\mathbb{F}\times\mathbb{F}\rightarrow\mathbb{G}$ and $\textsf{CommTag}:\mathbb{F}\setminus\{0\}\times\mathbb{F}\rightarrow\mathbb{G}\times\mathbb{G}$ to be needed later on, as follows:
\begin{align*}
\textsf{CommAmount}(a; x) &= x G + a H \ , \ x\xleftarrow{\$}\mathbb{F} \\
\textsf{CommTag}(k_a, k_b) &= (k_b G + k_a U, (1/k_a)G).
\end{align*}

The first security property is \textit{Completeness} (called \textit{Correctness} in Omniring), which means that if an e-note appears on the ledger, then the user owning it can honestly generate a \textit{valid} transaction spending it. Seraphis satisfying completeness immediately follows from the completeness properties of the cryptographic components and by inspection of the protocol description.

Next we consider the \textit{Balance} security property, which means that...

\begin{definition}[Balance]
Seraphis is balanced if it satisfies the following two conditions:
\begin{enumerate}
\item Both $(\emph{\textsf{Setup}},\emph{\textsf{CommAmount}})$ and $(\emph{\textsf{Setup}},\emph{\textsf{CommTag}})$ are binding.
\end{enumerate}
\end{definition}

\noindent Privacy

\noindent Non-slanderability

\subsection{Discussions}\label{sec-disc}

\section{Efficiency}

\section*{Acknowledgements}

\bibliographystyle{plain}
\bibliography{seraphis}

\appendix
\section{Composition proving system}\label{comp-prov}

\section{Security proofs for Seraphis}\label{proofs}

\section{?????}

\end{document}
