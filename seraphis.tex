\documentclass{article}
\usepackage[top=1.0in,bottom=1.0in,left=1.0in,right=1.0in]{geometry}
\usepackage{amsmath,amssymb,amsthm,amsfonts}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{remark}{Remark}

\title{A Report on Seraphis}
\author{coinstudent2048}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document contains a concise description of Seraphis \cite{seraphis}, a novel privacy-preserving transaction protocol abstraction, and its security model. This document will also serve as a suggestion to the organization of the contents of the final Seraphis paper.
\end{abstract}

\section{Introduction}
In a p2p (peer-to-peer) electronic cash system, the entire supply of currency exists as a digital record that can be stored by any person, and transactions (attempts to transfer money to new owners) are mediated by a network of \textit{peers} (usually called \textit{nodes})... ...An unfortunate consequence of cryptocurrencies being decentralized is that the ledger is \textit{public}, implying that all e-notes and transaction events are public knowledge. If amounts are in cleartext, addresses are trivially traceable, and e-notes to be spent are referenced directly, then observers can discern many details about users’ finances.

Hence, several confidential transaction protocols have been proposed to ensure financial privacy and currency fungibility. [List privacy technologies and limitations]
\subsection{Our contribution}
We introduce Seraphis, privacy-preserving transaction protocol abstraction, which means the unlike previous... Moreover...
\subsection{Acknowledgments}
Lelantus Spark

\section{Preliminaries}
\subsection{Public parameters}
Let $\lambda$ be the security parameter. Let $\mathbb{G}$ be a prime order group based on $\lambda$ where the Discrete Logarithm (DL), Computational Diffie-Hellman (CDH), and Decisional Diffie-Hellman (DDH) problems are hard, and let $\mathbb{F}$ be its scalar field. Let $G, H, X, U$ be generators of $\mathbb{G}$ with unknown DL relationship to each other. Note that these generators may be produced using public randomness. Let $a_{max}\in\mathbb{F}$ be the maximum amount value. Let $\mathcal{H}:\{0,1\}^*\rightarrow\mathbb{F}$ be a cryptographic hash function. We add a subscript to $\mathcal{H}$, such as $\mathcal{H}_1$, in lieu of domain-separating the hash function explicitly; any domain-separation method may be used in practice. All these public parameters are collected as $pp$, and we now define the setup algorithm: $pp\leftarrow\textsf{Setup}(1^{\lambda})$. $\textsf{Setup}$ is implicitly executed by all players involved in the beginning, hence it can be omitted in protocol descriptions.

The notation $\xleftarrow{\$}$ will be used to denote for a uniformly randomly chosen element, and $(1/x)$ for the modular inverse of $x\in\mathbb{F}$. Lastly, we use additive notation for group operations.

\subsection{E-notes and e-note images}
\begin{definition}\label{e-note}
An \textbf{\em e-note} for scalars $k_a^o, k_b^o, a \in\mathbb{F}$ is a tuple $(C, K^o, m)$ such that $C = x G + a H$ for $x\xleftarrow{\$}\mathbb{F}$, $K^o=k_a^o X + k_b^o U$, and $m$ is an arbitrary data.
\end{definition}
$C$ is called the \textbf{amount commitment} for the amount $a$ with blinding factor $x$, $K^o$ is called the \textbf{one-time address} for (one-time) private keys $k_a^o$ and $k_b^o$ (the $o$ superscript indicates ``one-time''), and $m$ is the \textbf{memo field}. We say that someone \textit{owns} an e-note if they know the corresponding scalars $k_a^o, k_b^o, a, x \in\mathbb{F}$.

\begin{definition}\label{e-note-img}
An \textbf{\em e-note image} for an e-note $(C, K^o, m)$ is a tuple $(C', K'^o, \tilde{K})$ such that
\begin{align*}
C' &= t_c G + C \\ &= (t_c+x)G + aH \\ &= v_c G + aH \ , \\
K'^o &= t_k G + K^o \\ &= t_k G + k_a^o X + k_b^o U \ ,\ \text{and} \\
\tilde{K} &= (k_b^o/k_a^o)U
\end{align*}
for $t_c, t_k \xleftarrow{\$}\mathbb{F}$ and independent to each other.
\end{definition}
$C'$ is called the \textbf{masked amount commitment}, $K'^o$ is called the \textbf{masked address}, and $\tilde{K}$ is called the \textbf{linking tag}.

\begin{definition}\label{recv-addr}
A \textbf{\em receiver address} is a tuple $(K^{dh}, K^v, K^s)$  such that $K^{dh}\in\mathbb{G}$, $K^v = k^v K^{dh}$, and $K^s = k_a^s X + k_b^s U$.
\end{definition}
$K^{dh}$ is called the \textbf{Diffie-Hellman base public key}, the $v$ superscript indicates ``view'', and the $s$ superscript indicates ``spend''. The reason for the name of $K^{dh}$ will be clear in the next subsection, while the reason for the names of superscripts will be discussed in the addressing schemes (Subsection \ref{addr-scheme}). We say that someone \textit{owns} a receiver address if they know the corresponding scalars $k^v, k_a^s, k_b^s \in\mathbb{F}$.

\subsection{Authenticated symmetric encryption scheme}
We require the use of an authenticated symmetric encryption scheme. The Diffie-Hellman base public key enables shared secrets between the sender and the receiver, which can be used to produce the key for encryption and the authentication tag. We denote the encryption and decryption of data $x$ with the input $k$ for Key Derivation Function (KDF) as ${\tt enc}[k](x)$ and ${\tt dec}[k](x)$, respectively. We put overlines (e.g. $\overline{x}$) to indicate encrypted data.

The required security properties for application to Seraphis are described in Section \ref{sec-symm}.

\section{A Seraphis transaction}\label{ser-tx}
We now describe a simple Seraphis transaction. This will be used as the basis for further instantiations and modifications (Section \ref{inst}) and for the security model (Section \ref{sec}).

Suppose that Alice would send $a_t\in\mathbb{F}$ amount of funds to Bob. Alice owns a set of e-notes $\{(C_i,K_i^o,m_i)\}_{i=1}^n$ with a total amount of $\big(\sum_{i=1}^{n}{a_i}\big)\ge a_t$, all \textit{connected} to a receiver address $(K_{ali}^{dh}, K_{ali}^v, K_{ali}^s)$. This ``connection'' will be elaborated later on. On the other hand, Bob owns a receiver address $(K_{bob}^{dh}, K_{bob}^v, K_{bob}^s)$. For Bob to receive the funds, he will now send his receiver address to Alice. Alice will actually send funds to two addresses: to Bob's and to herself (for the ``change'' $a_c = \sum_{i=1}^{n}{a_i} - a_t$ \textit{even if} $a_c=0$). Hence, Alice must create 2 new e-notes. She starts the transaction by doing the following:
\begin{enumerate}
    \item Generate $r_{ali}, r_{bob}\xleftarrow{\$}\mathbb{F}$ and independent to each other.
    \item Compute $R_{ali} = r_{ali}K_{ali}^{dh}$ and $R_{bob} = r_{bob}K_{bob}^{dh}$, then store $R_{ali}$ and $R_{bob}$ to new (empty) memos $m_{ali}$ and $m_{bob}$, respectively. The name for $K^{dh}$ should now be clear.
    \item Compute the sender-receiver shared secrets $q_{ali} = \mathcal{H}_1(r_{ali}K_{ali}^{v})$ and $q_{bob} = \mathcal{H}_1(r_{bob}K_{bob}^{v})$.
    \item Compute the one-time addresses $K_{ali}^o = \mathcal{H}_2(q_{ali})X + K_{ali}^s$ and $K_{bob}^o = \mathcal{H}_2(q_{bob})X + K_{bob}^s$. It is easy to see that $\mathcal{H}_2(q_{ali})$ and $\mathcal{H}_2(q_{ali})$ are uniformly random in the random oracle model.
    \item Compute the amount commitments $C_{ali} = \mathcal{H}_3(q_{ali})G + a_c H$ and $C_{bob} = \mathcal{H}_3(q_{bob})G + a_t H$. It is easy to see that the blinding factors $\mathcal{H}_3(q_{ali})$ and $\mathcal{H}_3(q_{bob})$ are uniformly random in the random oracle model.
    \item Encrypt the amounts: $\overline{a_c} = {\tt enc}[q_{ali}](a_c)$ and $\overline{a_t} = {\tt enc}[q_{ali}](a_t)$, and store $\overline{a_c}$ and $\overline{a_t}$ to memos $m_{ali}$ and $m_{bob}$, respectively.
\end{enumerate}
Alice now has two new e-notes: ${\tt enote}_{ali} = (C_{ali}, K_{ali}^o, m_{ali})$ and ${\tt enote}_{bob} = (C_{bob}, K_{bob}^o, m_{bob})$. These will then be stored to a new (empty) \textit{whole transaction} $T$. Other objects that will be stored to the whole transaction are from proving systems, which can be executed in \textit{any} order. Proving systems are discussed in the next subsections.

For specific instances of Seraphis, there might be changes in some parts of the above steps, and by reflection, in some parts of the Receipt. Here are some notable changes:
\begin{itemize}
\item For some addressing schemes, the input to $\mathcal{H}_2$, the input to $\mathcal{H}_3$, and the key for both ${\tt enc}$ and ${\tt dec}$ may be constructed differently and different to each other. Nevertheless, these inputs and key must still be sender-receiver shared secrets.
\item A Seraphis transaction can easily have multiple receivers aside from Bob, which implies that Alice will create more than 2 new e-notes. See Subsection \ref{sec-disc} for a discussion of how this affects the security model.
\item A Seraphis transaction can be collaboratively constructed by multiple players. This is the subject of the so-called ``proof dependency'' (Subsection \ref{proof-dep}). Also see Subsection \ref{sec-disc} for a discussion of how this affects the security model.
\end{itemize}

\subsection{Ownership and unspentness proofs}\label{own-unsp}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked address $K_i'^o$ is already in the e-note image ${\tt enimg}_i$ in $T$, then go to next step. Else generate $K_i'^o$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item If the linking tag $\tilde{K}_i$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $\tilde{K}_i$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item Prepare the proof transcripts $\Pi_{\text{o\&u}, i}$ for a non-interactive proving system for the following relation:
$$\{(G, X, U, K_i'^o, \tilde{K}_i\in\mathbb{G}; t_{k,i}, k_{a,i}^o, k_{b,i}^o\in\mathbb{F}): k_{a,i}^o \ne 0 \wedge K_i'^o = t_{k,i} G + k_{a,i}^o X + k_{b,i}^o U \wedge \tilde{K}_i = (k_{b,i}^o/k_{a,i}^o)U \}$$
    \item Append $\Pi_{\text{o\&u}, i}$ to $({\tt enimg}_i, \ldots)$ in $T$.
\end{enumerate}
Aside from verifying the proof transcripts, the Verifier must confirm that the linking tags do not yet appear in the ledger.

The required security properties for application to Seraphis are described in Section \ref{prov-prop}. Unlike what's presented above, we recommend a composition proving system in which instead of one $\Pi_{\text{o\&u}, i}$ per $i$, Alice only needs to produce one proof transcript for all $i$'s. We present this in Appendix \ref{comp-prov}, and provide proof that it satisfies the required security requirements.

\subsection{Amount balance}\label{amt-bal}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked amount commitment $C_i'$ is already in ${\tt enimg}_i$ in $T$, then exit this subsection. Else generate $C_i'$ from $(C_i, K_i^o, m_i)$ as per definition, \textit{except} for $i=n$. For the case of $i=n$, set
    $$v_{c,n} = \mathcal{H}_3(q_{ali}) + \mathcal{H}_3(q_{bob}) - \sum_{i=1}^{n-1}{v_{c,i}}.$$
    Note that the value of $v_{c,n}$ is still uniformly random because the values of $t_{c,i}$ for $i\in\{1,\ldots,n-1\}$ are uniformly random.
    \item Insert $C_i'$ to ${\tt enimg}_i$ in $T$.
\end{enumerate}
The generation of $v_{c,n}$ is as such so that the Verifier can verify the amount balance $\sum_{i=1}^n{C_i'}=C_{ali}+C_{bob}$.

\subsection{Membership proofs}\label{mem}
For each of Alice's owned e-notes in $\{(C_i,K_i^o,m_i)\}_{i=1}^n$, Alice must do the following:
\begin{enumerate}
    \item If the masked amount commitment $C_i'$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $C_i'$ from $(C_i, K_i^o, m_i)$ exactly like in Step 1 of Subsection \ref{amt-bal}, and insert it to ${\tt enimg}_i$ in $T$.
    \item If the masked address $K_i'^o$ is already in ${\tt enimg}_i$ in $T$, then go to next step. Else generate $K_i'^o$ from $(C_i, K_i^o, m_i)$ as per definition, and insert it to ${\tt enimg}_i$ in $T$.
    \item Collect $s-1$ number of random e-notes from the ledger and add her owned $(C_i,K_i^o,m_i)$, for a total of $s$ e-notes. The number $s$ is called the \textbf{anonymity size}.
    \item For each e-note in the collection (of size $s$), extract only the amount commitment and one-time address like this: $(C_j, K_j^o)$. Then arrange the $s$ e-notes in random positions. Alice now has an array (of length $s$) of pairs: $\mathbb{S}_i = \{(C_j, K_j^o)\}_{j=1}^s$, which is called the \textbf{ring}. Its elements $(C_j, K_j^o)$ are called the \textbf{ring members}. 
    \item Prepare the proof transcripts $\Pi_{\text{mem}, i}$ for a non-interactive proving system for the following relation:
$$\{(G, C_i', K_i'^o \in\mathbb{G}, \mathbb{S}_i\subset\mathbb{G}^2; \pi_i\in\mathbb{N}, t_{c,i}, t_{k,i}\in\mathbb{F}): 1\le\pi_i\le s \wedge C_i' - C_{\pi_i} = t_{c,i} G \wedge K_i'^o - K_{\pi_i}^o = t_{k,i} G \}$$
    \item Append $(\mathbb{S}_i, \Pi_{\text{mem}, i})$ to $({\tt enimg}_i, \ldots)$ in $T$.
\end{enumerate}
The required security properties for application to Seraphis are described in Section \ref{prov-prop}. Specific proving systems satisfying the requirement include CSAG (CLSAG \cite{clsag} without linking) and One-out-of-Many proving system adapted from Groth and Bootle \textit{et al.} \cite{groth, bootle}.

\subsection{Range proofs}\label{range}
For the new e-notes ${\tt enote}_{ali}$ and ${\tt enote}_{bob}$, Alice must do the following:
\begin{enumerate}
    \item Prepare the respective proof transcripts $\Pi_{\text{ran}, ali}$ and $\Pi_{\text{ran}, bob}$ for a non-interactive proving system for the following relation:
$$\{(G, H, C \in\mathbb{G}, a_{max}\in\mathbb{F}; x, a\in\mathbb{F}): C = x G + a H \wedge 0\le a \le a_{max}\}$$
    \item Store $\Pi_{\text{ran}, ali}$ and $\Pi_{\text{ran}, bob}$ to $T$.
\end{enumerate}

The required security properties for application to Seraphis are described in Section \ref{prov-prop}. Specific proving systems satisfying the requirement include Bulletproofs \cite{bp} and Bulletproofs+ \cite{bp-plus}.

\subsection{Receipt}
Once the construction of $T$ is completed, Alice sends it to the network. Its contents must now be
$$T=({\tt enote}_{ali}, {\tt enote}_{bob}, \Pi_{\text{ran}, ali}, \Pi_{\text{ran}, bob}, \{({\tt enimg}_i, \Pi_{\text{o\&u}, i}, \mathbb{S}_i, \Pi_{\text{mem}, i})\}_{i=1}^n).$$
\noindent Suppose that the Verifier successfully verified $T$, hence $T$ is now stored in the ledger. When Bob scans the ledger for new transactions, he must do the following for every $T$ he encounters:
\begin{enumerate}
    \item Get a new e-note $(C, K^o, m)$ in $T$. Note that $m$ contains $(R, \overline{a})$ (see the beginning of this whole section).
    \item Compute the nominal sender-receiver shared secret: $q_{nom} = \mathcal{H}_1(k_{bob}^v R)$.
    \item Compute the nominal spend public key: $K_{nom}^s = K^o - \mathcal{H}_2(q_{nom})X$. If $K_{nom}^s = K_{bob}^s$, then the e-note is \textit{connected} to Bob's receiver address, and proceed to the next step (this is the ``connection'' hinted at the beginning of this whole section).  Otherwise (if not equal), the e-note is not connected, and hence go to Step 1.
    \item Decrypt the amount: $a = {\tt dec}[q_{nom}](\overline a)$.
    \item Compute the nominal amount commitment: $C_{nom} = \mathcal{H}_3(q_{nom})G + a H$. If $C_{nom} \ne C$, then the e-note is malformed and cannot be spent.
    \item Compute the nominal linking tag: $\tilde{K}_{nom} = (k_{b, bob}^s/(k_{a, bob}^s + \mathcal{H}_2(q_{nom})))U$. If he finds a copy of $\tilde{K}_{nom}$ in the ledger, then the e-note has already been spent.
\end{enumerate}
If an e-note $(C, K^o, m)$ is connected to Bob's receiver address, then he knows the corresponding scalars of that e-note: $(k_a^o, k_b^o, a, x) = (k_{a, bob}^s + \mathcal{H}_2(q_{nom}), k_{b, bob}^s, a, \mathcal{H}_3(q_{nom}))$. Hence, ``connection'' implies e-note ownership. The transaction is complete for Bob.

For Alice to receive the ``change'' e-note, she must do the same above steps. After that, the transcation is complete for Alice. This finishes a Seraphis trancation.

\section{Instantiations and Modifications}\label{inst}
There are a number of details to consider when implementing Seraphis in a real cryptocurrency. Aside from instances of proving systems mentioned already in the previous section, this section is comprised of `recommendations' for instantiations and modifications of other parts of Seraphis, which are inspired by historical privacy-focused cryptocurrency implementations.

\subsection{Addressing schemes}\label{addr-scheme}
\subsection{Multisignature operations}
\subsection{Proof dependency}\label{proof-dep}
\subsubsection*{Transaction Chaining}
\subsection{Transaction fees}
\subsection{Coinbase transactions}
\subsection{Squashed e-note model}
\subsection{?????}

\section{Security model}\label{sec}
For a start, we assume that the distributed ledger is immutable. Therefore, the adversary in our analysis will never be able to modify transactions already stored in the ledger. This ledger immutability can be actualized through, for instance, the Nakamoto consensus protocol \cite{bitcoin}.

Subsections \ref{prov-prop} to \ref{Comm} outline the required security properties of the cryptographic components for Seraphis, then Subsection \ref{sec-thm} is the main security analysis of Seraphis, and Subsection \ref{sec-disc} discusses how some instantiations and modifications described in Section \ref{inst} affect the security analysis.

\subsection{Proving systems security properties}\label{prov-prop}
We require some proving systems to be used in Seraphis to be zero-knowledge. Starting with interactive protocol description, the proving systems must satisfy the following three security properties. The precise definitions of these properties are common and found, for instance, in \cite{groth}.
\begin{itemize}
    \item \textit{Completeness}: If the prover knows a witness to the statement, she should always be able to generate a proof for that statement that convinces the verifier.
    \item \textit{Soundness}: If the prover does not know a witness to the statement, she should never be able to generate a proof for that statement that convinces the verifier. Moreover, there exists an \textit{witness extractor} that has an ability to ``rewind time'' and make the prover answer several different challenges. From the valid (by verifier) answers of the prover, it should be possible for the witness extractor to extract a witness.
    \item \textit{Honest Verifier Zero-Knowledge}: The protocol should not reveal anything about the prover’s witness. Moreover, assuming that challenges must be honestly generated, there exists a \textit{simulator} such that even without knowledge of a witness, the probability distribution of the simulator's valid transcripts (all data being sent and received in the protocol) is equal to the probability distribution of actual valid transcripts by a prover and a verifier.
\end{itemize}
Fiat-Shamir heuristic \cite{fiat-shamir} is applied to make interactive proving systems non-interactive. Moreover, Fiat-Shamir heuristic transforms interactive protocols satisfying HVZK into non-interactive (fully) zero-knowledge (NIZK) protocols in the random oracle model.

\subsection{Authenticated symmetric encryption scheme}\label{sec-symm}
We require that the authenticated symmetric encryption scheme has the following properties: indistinguishable against chosen-plaintext attack (IND-CPA), indistinguishable against adaptive chosen-ciphertext attack (IND-CCA2), and key-private under chosen-ciphertext attacks (IK-CCA).

\subsection{Commitment schemes}\label{Comm}

We define a commitment scheme as a tuple $(\textsf{Setup}, \textsf{Comm})$. $\textsf{Setup}$ is the setup algorithm: $pp\leftarrow\textsf{Setup}(1^{\lambda})$, and $\textsf{Comm}:\mathcal{M}\times{\chi}\rightarrow\mathcal{C}$ is the $\textit{commitment function}$, where $\mathcal{M}$ is the message space, $\chi$ is the randomness space, and $\mathcal{C}$ is the commitment space. Note that $\mathcal{M}, \chi$ and $\mathcal{C}$ are all constructed from $pp$.
To commit to a message $m \in M$, the sender selects $r\xleftarrow{\$}\chi$ and computes the commitment $C = \textsf{Comm}(m; r)$. We define the required security properties of commitment schemes.

\begin{definition}[Hiding Property]
A commitment scheme $(\emph{\textsf{Setup}}, \emph{\textsf{Comm}})$ is hiding if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\left| \frac{1}{2} - \emph{\textsf{Pr}}\left[
\begin{array}{c|c}
    \begin{gathered}
        b' = b
    \end{gathered}
    &
    \begin{gathered}
        pp\leftarrow\emph{\textsf{Setup}}(1^{\lambda}); (m_0, m_1)\leftarrow\mathcal{A}(pp); \\
        b\xleftarrow{\$}\{0,1\}; r \xleftarrow{\$}\chi; \\
        C = \emph{\textsf{Comm}}(m_b; r); b'\leftarrow\mathcal{A}(C)
    \end{gathered}
\end{array}
\right]\right|
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
\end{definition}

\begin{definition}[Binding Property]
A commitment scheme $(\emph{\textsf{Setup}}, \emph{\textsf{Comm}})$ is binding if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}
\left[
\begin{array}{c|c}
    \begin{gathered}
         \emph{\textsf{Comm}}(m_0;r_0) \\
        = \emph{\textsf{Comm}}(m_1;r_1) \\
        \wedge\ m_0 \ne m_1
    \end{gathered}
    &
    \begin{gathered}
        pp\leftarrow\emph{\textsf{Setup}}(1^{\lambda}); \\
        (m_0,m_1,r_0,r_1)\leftarrow\mathcal{A}(pp)
    \end{gathered}
\end{array}
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
\end{definition}
\subsection{Seraphis security properties}\label{sec-thm}
The required security properties are those in Omniring's security model \cite{omniring}, with modifications to fit in Seraphis. The Omniring paper presents a rigorous formalization of RingCT constructions, providing precision for security analysis against several realistic attacks. Proofs for the theorems are found in Section \ref{proofs}.

We first define commitment functions $\textsf{CommAmount}:\mathbb{F}\times\mathbb{F}\rightarrow\mathbb{G}$ and $\textsf{CommTag}:\mathbb{F}\setminus\{0\}\times\mathbb{F}\times\mathbb{F}\rightarrow\mathbb{G}\times\mathbb{G}$ to be needed later on, as follows:
\begin{align*}
\textsf{CommAmount}(a; x) &= x G + a H \ , \ x\xleftarrow{\$}\mathbb{F}\ \text{if}\ x\ \text{is not specified.} \\
\textsf{CommTag}(k_a, k_b; t_k) &= (t_k G + k_a X + k_b U, (k_b/k_a)U)\ , \ t_k\xleftarrow{\$}\mathbb{F}\ \text{if}\ t_k\ \text{is not specified.}
\end{align*}
$\textsf{CommAmount}$ corresponds to the structure of amount commitment $C$, while $\textsf{CommTag}$ corresponds to the combination of structures of masked address $K'^o$ and linking tag $\tilde{K}$.

The first security property is \textbf{Completeness} (called \textit{Correctness} in Omniring), which means that if an e-note appears on the ledger, then the user owning it can honestly generate a valid (by verifier) transaction spending it. Seraphis satisfying completeness immediately follows from the completeness properties of the cryptographic components and by inspection of the protocol description.

Next we consider the \textbf{Balance} property, which means that a spender adversary should never be able to spend more amounts than he truly owns, hence preventing double-spending. Balance property has two subproperties: the first involves the binding property. $\textsf{CommAmount}$ is binding means that the spender adversary should not be able to change the e-note amounts when spending the e-notes he owns, while $\textsf{CommTag}$ is binding means that the spender adversary should not be able to make a new linking tag from an e-note he already spent, which is an attempt of double-spending the e-note.

The second subproperty involves an experiment $\textsf{BAL}(\mathcal{A}, \mathcal{E}_{\mathcal{A}}, 1^{\lambda})$ between a $\textsf{PPT}$ spender adversary $\mathcal{A}$ and a witness extractor $ \mathcal{E}_{\mathcal{A}}$. $\mathcal{A}$ succeeds in the experiment (i.e. $\textsf{BAL}(\mathcal{A}, \mathcal{E}_{\mathcal{A}}, 1^{\lambda})=1$) if he managed to generate a valid transaction such that all private information related to amounts like the amounts themselves, discrete log of linking tags, spent e-note private keys, etc. are \textit{not all equal} to the data extracted by $\mathcal{E}_{\mathcal{A}}$. Now the two subproperties combined says that if $\mathcal{A}$ succeeds in the experiment, then it is guaranteed that he broke the binding properties of $\textsf{CommAmount}$ or $\textsf{CommTag}$.

\begin{figure}[htbp]
\centering
\fbox{\begin{minipage}{0.85\textwidth}
\underline{$\textsf{BAL}(\mathcal{A}, \mathcal{E}_{\mathcal{A}}, 1^{\lambda})$}
\begin{itemize}
\item $pp\leftarrow\textsf{Setup}(1^{\lambda})$.
\item $\mathcal{A}$ is provided $k_v, k_a^s, k_b^s\in\mathbb{F}$ to construct the address ${\tt addr}_{\mathcal{A}} = (K_{\mathcal{A}}^{dh}, K_{\mathcal{A}}^v, K_{\mathcal{A}}^s)$, ${\tt enote}_{\mathcal{A}}=\{(C_i,K_i^o,m_i)\}_{i=1}^n$ in the ledger which are connected to that address, and a receiver's address ${\tt addr}_{\mathcal{B}} = (K_{\mathcal{B}}^{dh}, K_{\mathcal{B}}^v, K_{\mathcal{B}}^s)$.
\item $T\leftarrow\mathcal{A}(pp, {\tt addr}_{\mathcal{A}}, {\tt addr}_{\mathcal{B}}, {\tt enote}_{\mathcal{A}})$. $\mathcal{A}$ spends some e-notes to ${\tt addr}_{\mathcal{B}}$.
\item $(\{(t_{c,i}, t_{k,i}, k_{a,i}^o, k_{b,i}^o, \pi_i)\}_{i=1}^n, x_{\mathcal{B}}, a_{\mathcal{B}})\leftarrow\mathcal{E}_{\mathcal{A}}(pp, T)$.
\item $b_0:=1$ if Verifier verified $T$ as valid, else $:=0$.
\item $b_1:=1$ if $\textsf{CommAmount}(a_{\mathcal{B}}; x_{\mathcal{B}}) = C$ in ${\tt enote}_{\mathcal{B}}$ in $T$, else $:=0$.
\item $b_2:=1$ if for all $i\in\{1,\ldots,n\}$, $\textsf{CommAmount}(t_{c,i}; 0) = C_i' - C_{\pi_i}$ in $T$, else $:=0$.
\item $b_3:=1$ if for all $i\in\{1,\ldots,n\}$, $\textsf{CommAmount}(t_{k,i}; 0) = K_i'^o - K_{\pi_i}^o$ in $T$, else $:=0$.
\item $b_4:=1$ if for all $i\in\{1,\ldots,n\}$, $\textsf{CommTag}(k_{a,i}^o, k_{b,i}^o; t_{k,i}) = (K_i'^o, \tilde{K}_i)$ in $T$, else $:=0$.
\item $b_5:=1$ if $\sum_{i=1}^n{a_{\mathcal{A}, i}}\ge a_{\mathcal{B}}$ where $a_{\mathcal{A}, i}$ is the amount of $i$th spent e-note and $a_{\mathcal{B}}$ is the amount received by ${\tt addr}_{\mathcal{B}}$, else $:=0$.
\item Return $b_0 \wedge \neg(b_1 \wedge b_2 \wedge b_3 \wedge b_4 \wedge b_5)$.
\end{itemize}
\end{minipage}}
\caption{Balance experiment $\textsf{BAL}$}
\label{exp-bal}
\end{figure}

\begin{definition}[Balance]
Seraphis is balanced if it satisfies the following two conditions:
\begin{enumerate}
\item Both $(\emph{\textsf{Setup}},\emph{\textsf{CommAmount}})$ and $(\emph{\textsf{Setup}},\emph{\textsf{CommTag}})$ are binding.
\item For every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a $\emph{\textsf{PPT}}$ extractor $\mathcal{E}_{\mathcal{A}}$ and a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}
\left[
\emph{\textsf{BAL}}(\mathcal{A}, \mathcal{E}_{\mathcal{A}}, 1^{\lambda})=1
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
where $\emph{\textsf{BAL}}$ is described in Figure \ref{exp-bal}.
\end{enumerate}
\end{definition}
\begin{theorem}[Balance]
If Ownership and Unspentness proofs are special sound, Range proofs are special sound, and Membership proofs are unforgeable, then Seraphis is balanced.  
\end{theorem}

Next we consider the \textbf{Privacy} property, which means that an adversary should never be able to detect the spender, receiver, and amounts in any transaction, hence providing sender and receiver anonymity, and confidential transfer of amounts. Privacy property involves an experiment $\textsf{PRV}(\mathcal{A}, 1^{\lambda})$ on a $\textsf{PPT}$ adversary $\mathcal{A}$. The adversay $\mathcal{A}$ succeeds in the experiment (i.e. $\textsf{PRV}(\mathcal{A}, 1^{\lambda})=1$) if

\begin{figure}[htbp]
\centering
\fbox{\begin{minipage}{0.85\textwidth}
\underline{$\textsf{PRV}(\mathcal{A}, 1^{\lambda})$}
\begin{itemize}
\item $pp\leftarrow\textsf{Setup}(1^{\lambda})$.
\item $\mathcal{A}$ is provided $k_v, k_a^s, k_b^s\in\mathbb{F}$ to construct the address ${\tt addr}_{\mathcal{A}} = (K_{\mathcal{A}}^{dh}, K_{\mathcal{A}}^v, K_{\mathcal{A}}^s)$, ${\tt enote}_{\mathcal{A}}=\{(C_i,K_i^o,m_i)\}_{i=1}^n$ in the ledger which are connected to that address, and a receiver's address ${\tt addr}_{\mathcal{B}} = (K_{\mathcal{B}}^{dh}, K_{\mathcal{B}}^v, K_{\mathcal{B}}^s)$.
\item $b'\leftarrow\mathcal{A}(pp, T)$
\item Return $1$ if $b = b'$, else $0$.
\end{itemize}
\end{minipage}}
\caption{Privacy experiment $\textsf{PRV}$}
\label{exp-prv}
\end{figure}

\begin{definition}[Privacy]
Seraphis is private if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exist a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}
\left[
\emph{\textsf{PRV}}(\mathcal{A}, 1^{\lambda})=1
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
where $\emph{\textsf{PRV}}$ is described in Figure \ref{exp-prv}.
\end{definition}

Lastly, we consider the \textbf{Non-slanderability}, which means that an adversary should never be able to spend e-notes on behalf of the owner of the e-notes.

\begin{figure}[htbp]
\centering
\fbox{\begin{minipage}{0.85\textwidth}
\underline{$\textsf{NSLAND}(\mathcal{A}, 1^{\lambda})$}
\begin{itemize}
\item $pp\leftarrow\textsf{Setup}(1^{\lambda})$.
\item $\mathcal{A}$ is provided $k_v, k_a^s, k_b^s\in\mathbb{F}$ to construct the address ${\tt addr}_{\mathcal{A}} = (K_{\mathcal{A}}^{dh}, K_{\mathcal{A}}^v, K_{\mathcal{A}}^s)$, ${\tt enote}_{\mathcal{A}}=\{(C_i,K_i^o,m_i)\}_{i=1}^n$ in the ledger which are connected to that address, and a receiver's address ${\tt addr}_{\mathcal{B}} = (K_{\mathcal{B}}^{dh}, K_{\mathcal{B}}^v, K_{\mathcal{B}}^s)$.
\item $b'\leftarrow\mathcal{A}(pp, T)$
\item Return $b_0 \wedge b_1 \wedge b2$.
\end{itemize}
\end{minipage}}
\caption{Non-slanderability experiment $\textsf{NSLAND}$}
\label{exp-nsland}
\end{figure}

\begin{definition}[Non-slanderability]
Seraphis is non-slanderable if for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exist a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}
\left[
\emph{\textsf{NSLAND}}(\mathcal{A}, 1^{\lambda})=1
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
where $\emph{\textsf{NSLAND}}$ is described in Figure \ref{exp-nsland}.
\end{definition}

\subsection{Discussions}\label{sec-disc}

\section{Efficiency}

\bibliographystyle{plain}
\bibliography{seraphis}

\appendix

\section{Composition proving system}\label{comp-prov}
The composition proving system is a protocol for the relation:
\begin{multline*}
\Big\{\big(G, X, U\in\mathbb{G}, \{K_i\}_{i=1}^n, \{K_{t1,i}\}_{i=1}^n, \{\tilde{K}_i\}_{i=1}^n \in\mathbb{G}^n; \{x_i\}_{i=1}^n, \{y_i\}_{i=1}^n, \{z_i\}_{i=1}^n \in\mathbb{F}^n\big): \\ \bigwedge_{i=1}^n{\big(y_i \ne 0 \wedge K_i = x_i G + y_i X + z_i U \wedge K_{t1,i} = (1/y_i)K_i \wedge \tilde{K}_i = (z_i/y_i)U\big)} \Big\}
\end{multline*}
Now the Prover only needs to produce one proof transcript for all $i$'s instead of one proof transcript for each $i$. This protocol is based on the concise approach from \cite{clsag} to reduce proof sizes when constructing multiple proofs in parallel. Notice the extra $\{K_{t1,i}\}_{i=1}^n$ in the relation. This should not affect the proving system's applicability for Ownership and Unspentness proof because all $y_i$'s are still hidden in $K_{t1,i}$ (by the DL assumption) and the required relationships for $\{K_i\}_{i=1}^n$ and $\{\tilde{K}_i\}_{i=1}^n$ are still proven.

The protocol proceeds as follows:
\begin{enumerate}
\item The Prover generates $\alpha_a, \alpha_b, \alpha_i \xleftarrow{\$}\mathbb{F}\ ,\ \forall i\in\{1,\ldots,n\}$. The Prover computes $(A_a, A_b) = (\alpha_a G, \alpha_b U)$ and $A_{i}=\alpha_i K_i\ ,\ \forall i\in\{1,\ldots,n\}$, and sends $(A_a, A_b, \{A_i\}_{i=1}^n)$ to the verifier.
\item Both the Prover and Verifier compute $K_{t2,i} = K_{t1,i} - X - \tilde{K}_i\ ,\ \forall i\in\{1,\ldots,n\}$.
\item The Verifier sends a challenge $c\xleftarrow{\$}\mathbb{F}$ to the Prover.
\item The Prover computes the responses:
\begin{align*}
r_{a} &= \alpha_a - c \sum_{j=1}^{n}{\mathcal{H}_7(\{K_{t2,i}\}_{i=1}^n, j) (x_j/y_j)} \\
r_{b} &= \alpha_b - c \sum_{j=1}^{n}{\mathcal{H}_8(\{\tilde{K}_i\}_{i=1}^n, j) (z_j/y_j)} \\
r_{i} &= \alpha_i - c (1/y_i)\ ,\ \forall i\in\{1,\ldots,n\}\\
\end{align*}
and sends those values to the Verifier.
\item The Verifier checks the following equalities. If any of them fail, then the Prover has failed to satisfy the composition proof system.
\begin{align*}
A_{a} &= r_a G + c \sum_{j=1}^{n}{\mathcal{H}_7(\{K_{t2,i}\}_{i=1}^n, j) K_{t2,j}} \\
A_{b} &= r_b U + c \sum_{j=1}^{n}{\mathcal{H}_8(\{\tilde{K}_i\}_{i=1}^n, j) \tilde{K}_j} \\
A_{i} &= r_i K_i + c K_{t1,i}\ ,\ \forall i\in\{1,\ldots,n\}\\
\end{align*}
\end{enumerate}
We now prove that the protocol is complete, (computationally) sound, and honest-verifier zero knowledge, all if $G$, $X$, and $U$ are mutually independent and $\mathcal{H}$ is a random oracle.

\begin{proof}
For completeness, note that $\forall i\in\{1,\ldots,n\}$, knowledge of $(x_i/y_i$, $z_i/y_i$, $1/y_i)$ is also enough to satisfy the proving relation, and
\begin{align*}
K_{t2,i} &= K_{t1,i} - X - \tilde{K}_i \\ &= (1/y_i)(x_i G + y_i X + z_i U) - X - (z_i/y_i)U \\
&= (x_i/y_i)G + X + (z_i/y_i) U - X - (z_i/y_i)U \\ &= (x_i/y_i)G.
\end{align*}
Then the property follows from inspection.

For honest-verifier zero knowledge, we construct a valid simulator producing transcripts with probability distribution identical to the probability distribution of actual valid transcripts by Prover and Verifier. The simulator generates $c, r_a, r_b, r_i \xleftarrow{\$}\mathbb{F}\ ,\ \forall i\in\{1,\ldots,n\}$. Then the simulator computes $A_{a}, A_{b}, \{A_{i}\}_{i=1}^n$ exactly according to Step 5 of the protocol description. Because of this last step, the Verifier will mark the simulated transcripts as \textit{valid}. Now assume that $G$, $X$, and $U$ are mutually independent and $\mathcal{H}$ is a random oracle. Observe that the simulated transcripts are all uniformly random because $c, r_a, r_b, \{r_i\}_{i=1}^n$ are uniformly randomly selected. On the other hand, observe that actual valid transcripts between Prover and Verifier are also uniformly random because the Prover's $\alpha_a, \alpha_b, \{\alpha_i\}_{i=1}^n$ and the Verifier's $c$ are all uniformly randomly selected. Hence the two probability distributions are identical.

For computational soundness (with respect to DL assumption), the proof is by contraposition. Suppose that a $\textsf{PPT}$ adversarial prover $\mathcal{A}$ \textit{not} knowing a witness, can produce a valid transcript $(A_a, A_b, \{A_i\}_{i=1}^n,c, r_a, r_b, \{r_i\}_{i=1}^n)$ with an honest verifier with non-negligible probability. From the third equation in Step 5, $\forall i\in\{1,\ldots,n\}$:
\begin{align*}
A_{i} &= r_i K_i + c K_{t1,i} \\
\implies\alpha_i K_i &= r_i K_i + c (1/y_i)K_i \\
\implies\alpha_i &= r_i + c(1/y_i) \\
\implies(1/y_i) &= (\alpha_i - r_i)(1/c)
\end{align*}
Hence solving the discrete log (DL) problem for $K_{t1,i} = (1/y_i)K_i$ with non-negligible probability.
\end{proof}

Fiat-Shamir heuristic transforms interactive protocols satisfying HVZK into non-interactive (fully) zero-knowledge (NIZK) protocols in the random oracle model. Applying Fiat-Shamir heuristic to the composition proving system should be straightforward.

\section{Security proofs for Seraphis}\label{proofs}
We first present a lemma which is helpful in proofs by reduction.

\begin{definition}\label{negl}
A function $f:\mathbb{N}\rightarrow\mathbb{R}$ is \textbf{\em negligible} if for every polynomial $p(\cdot)$ there exists an $N\in\mathbb{N}$ such that for all integers $n>N$ it holds that $f(n)<\frac{1}{p(n)}$.
\end{definition}
\noindent Definition \ref{negl} is from Katz \& Lindell \cite{katz-lindell}. We prove the following lemma:

\begin{lemma}\label{negl-exp}
If $f:\mathbb{N}\rightarrow\mathbb{R}$ is non-negligible, then $g(\cdot)=f(\cdot)^m$ for any $m\in\mathbb{N}$ and $m>1$ is non-negligible.
\end{lemma}
\begin{proof}
The non-negligibility of $f$ means that there exists a polynomial $p(\cdot)$ such that for all $N\in\mathbb{N}$, there exists an $n>N$ such that $f(n)\ge\frac{1}{p(n)}$. Let $p_f(\cdot)$ be such polynomial and $n_f$ be such $n>N$. Then setting $p_g(\cdot)=p_f(\cdot)^m$ and $n_g=n_f$ suffices for non-negligibility of $g$ because $f(n_f)\ge\frac{1}{p_f(n_f)}\implies f(n_f)^m\ge\frac{1}{p_f(n_f)^m}$.
\end{proof}
\noindent Lemma \ref{negl-exp} justifies the usage of finite number of ``breaks'' in proofs by reduction. For a start, the probability for breaking a hardness assumption $\textsf{HA}$ is a function of $\lambda$. For now, we denote this function as $\textsf{Pr}[\textsf{HA}(\lambda)]$. Hence, for $m>1$, the probability for breaking $\textsf{HA}$ $m$-times $\textsf{Pr}[\wedge_{i=1}^{m}{\textsf{HA}_i(\lambda)}]\ge\textsf{Pr}[\textsf{HA}(\lambda)]^m$. Now Lemma \ref{negl-exp} says that if $\textsf{Pr}[\textsf{HA}(\lambda)]$ is non-negligible (or equivalently, for all negligible function $\textsf{negl}(\lambda)$, $\textsf{Pr}[\textsf{HA}(\lambda)]\ge\textsf{negl}(\lambda)$), then $\textsf{Pr}[\textsf{HA}(\lambda)]^m$ must also be non-negligible and hence $\textsf{Pr}[\wedge_{i=1}^{m}{\textsf{HA}_i(\lambda)}]$ is also non-negligible. Nevertheless, the number of breaks should still be documented in proofs.
\\\\
Now we present theorems that will be directly applied to the proofs of security properties of Seraphis:

\begin{theorem}
Let $(*)$ be the following hardness assumption relative to $\emph{\textsf{Setup}}$: for all $n>1$ and for every $\emph{\textsf{PPT}}$ adversary $\mathcal{A}$, there exists a negligible function $\emph{\textsf{negl}}(\lambda)$ such that
\begin{align*}
\emph{\textsf{Pr}}\left[
\begin{array}{c|c}
    \begin{gathered}
        \exists z_i(z_i \neq 0), i\in\{1, \ldots, n\} \\
        \wedge\ \sum_{i=1}^{n}{z_i G_i}=H
    \end{gathered}
    &
    \begin{gathered}
        pp\leftarrow\emph{\textsf{Setup}}(1^{\lambda}); \\
        G_1,\ldots,G_n, H\xleftarrow{\$}\mathbb{G}; \\
        \{z_i\}_{i=1}^n\in\mathbb{F}\leftarrow\mathcal{A}(pp, \{G_i\}_{i=1}^n, H) \\
    \end{gathered}
\end{array}
\right]
\le \emph{\textsf{negl}}(\lambda).
\end{align*}
Then if the DL assumption holds, then $(*)$ holds.
\end{theorem}
\begin{proof}
The proof is by contraposition. Suppose that there exists an $n>1$ such that there exists a $\textsf{PPT}$ adversary $\mathcal{A}$ that solves $(*)$ with non-negligible probability. Let $A, B\in\mathbb{G}$ (both $\ne 0$) be some group elements to find discrete log for. Then set $G_1=G_2=\ldots=G_n=A, H=B$, and input these to $\mathcal{A}$, which with non-negligble probability, outputs $\{z_i\}_{i=1}^n$ such that $(\sum_{i=1}^n{z_i}) A = B$.
\end{proof}
\end{document}
